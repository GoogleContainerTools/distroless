#!/usr/bin/env node
const fs = require("fs");

const version = process.argv[2];

const bunVersion = {};

const architectures = ["amd64", "arm64"];

async function getChecksum(version, platform) {
	const url = `https://github.com/oven-sh/bun/releases/download/bun-v${version}/SHASUMS256.txt`;

	const res = await fetch(url, {
		redirect: "follow",
		headers: {
			"User-Agent": "distroless-checksum-script",
		},
	});

	if (!res.ok) throw new Error(`HTTP ${res.status} fetching SHASUMS256.txt`);

	const text = await res.text();

	const lines = text.split("\n");

	// The filename pattern used by Bun
	const targetFile = `bun-linux-${platform}.zip`;

	for (const line of lines) {
		if (line.includes(targetFile)) {
			const [checksum] = line.split(/\s+/);
			return checksum;
		}
	}

	throw new Error(`Checksum not found for platform: ${platform}`);
}

const fetchChecksum = async () => {
	await Promise.all(
		architectures.map(async (key) => {
			const arch = key === "amd64" ? "x64" : "aarch64";

			try {
				const checksum = await getChecksum(version, arch);
				bunVersion[key] = {
					checksum: checksum,
					suffix: arch,
				};
			} catch (error) {
				console.error(error);
			}
		}),
	);
};

fetchChecksum().then(() => {
	let bunArchives = `"bun"

BUILD_TMPL = """\
# GENERATED BY bun.bzl
load("@distroless//private/pkg:debian_spdx.bzl", "debian_spdx")
load("@distroless//private/util:merge_providers.bzl", "merge_providers")
load("@rules_pkg//:pkg.bzl", "pkg_tar")

pkg_tar(
    name = "data",
    srcs = glob(
        [
            "output/bun",
        ],
    ),
    package_dir = "/bun",
    strip_prefix = "external/{canonical_name}/output"
)

pkg_tar(
    name = "_control",
    srcs = ["control"]
)

debian_spdx(
    name = "spdx",
    control = ":_control.tar",
    data = ":data.tar",
    package_name = "{package_name}",
    spdx_id = "{spdx_id}",
    sha256 = "{sha256}",
    urls = [{urls}]
)

merge_providers(
    name = "{name}",
    srcs = [":data", ":spdx"],
    visibility = ["//visibility:public"],
)
"""

def _impl(rctx):
    rctx.report_progress("Fetching {}".format(rctx.attr.package_name))
    rctx.download_and_extract(
        url = rctx.attr.urls,
        sha256 = rctx.attr.sha256,
        type = rctx.attr.type,
        stripPrefix = rctx.attr.strip_prefix,
        output = "output",
    )
    rctx.template(
        "control",
        rctx.attr.control,
        substitutions = {
            "{{VERSION}}": rctx.attr.version,
            "{{ARCHITECTURE}}": rctx.attr.architecture,
            "{{SHA256}}": rctx.attr.sha256,
        },
    )
    rctx.file(
        "BUILD.bazel",
        content = BUILD_TMPL.format(
            canonical_name = rctx.attr.name,
            name = rctx.attr.name.split("~")[-1],
            package_name = rctx.attr.package_name,
            spdx_id = rctx.attr.name,
            urls = ",".join(['"%s"' % url for url in rctx.attr.urls]),
            sha256 = rctx.attr.sha256,
        ),
    )

bun_archive = repository_rule(
    implementation = _impl,
    attrs = {
        "urls": attr.string_list(mandatory = True),
        "sha256": attr.string(mandatory = True),
        "type": attr.string(default = ".zip"),
        "strip_prefix": attr.string(),
        "package_name": attr.string(default = "bun"),
        "version": attr.string(mandatory = True),
        "architecture": attr.string(mandatory = True),
        # control is only used to populate the sbom, see https://github.com/GoogleContainerTools/distroless/issues/1373
        # for why writing debian control files to the image is incompatible with scanners.
        "control": attr.label(),
    },
)

def _bun_impl(module_ctx):
    mod = module_ctx.modules[0]

    if len(module_ctx.modules) > 1:
        fail("bun.archive should be called only once")
    if not mod.is_root:
        fail("bun.archive should be called from root module only.")

    # Bun (https://github.com/oven-sh/bun/releases)
    # Follow Node's maintenance schedule and support all LTS versions that are not end of life`;

	for (const key of architectures) {
		const arch = bunVersion[key];
		const archUrl = key === "amd64" ? "x64" : "aarch64";
		const url = `https://github.com/oven-sh/bun/releases/download/bun-v${version}/bun-linux-${archUrl}.zip`;

		bunArchives += "\n";
		bunArchives += `
    bun_archive (
        name = "bun_${key}",
        sha256 = "${arch.checksum}",
        strip_prefix = "bun-linux-${arch.suffix}/",
        urls = ["${url}"],
        version = "${version}",
        architecture = "${key}",
        control = "//bun:control",
    )`;
	}

	bunArchives += `

    return module_ctx.extension_metadata(
        root_module_direct_deps = [`;
	for (const key of architectures) {
		bunArchives += `
            "bun_${key}",`;
	}
	bunArchives += `
        ],
        root_module_direct_dev_deps = [],
    )

_archive = tag_class(attrs = {})

bun = module_extension(
    implementation = _bun_impl,
    tag_classes = {
        "archive": _archive,
    },
)
`;

	fs.writeFile("private/extensions/bun.bzl", bunArchives, (error) => {
		if (error) {
			console.error(error);
		}
	});

	const testData = `schemaVersion: "2.0.0"
commandTests:
  - name: bun
    command: "/bun/bun"
    args: ["--version"]
    expectedOutput: ["${version}"]
`;

	fs.writeFile(`bun/testdata/bun.yaml`, testData, (err) => {
		if (err) {
			console.error(err);
		}
	});
});
